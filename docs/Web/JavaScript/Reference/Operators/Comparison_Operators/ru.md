---
version: prototype1
revision_id: 921777
locale: ru
slug: Web/JavaScript/Reference/Operators/Операторы_сравнения
tags: "JavaScript" "Операторы"
title: Операторы сравнения
summary: 
keywords: 
needs_technical_review: False
needs_editorial_review: False
needs_localization: False
table_of_contents_depth: 1
based_on: None
---
<div>{{jsSidebar("Operators")}}</div>

<p>В JavaScript имеются как строгие сравнения, так и сравнения с преобразованием типа операндов. Строгие сравнения (к примеру, ===) истинны только в том случае, если типы сравниваемых значений являются одинаковыми (к примеру: string-string, number-number). Однако, чаще используются сравнения с преобразованием типов (к примеру, ==). Такой тип сравнения, перед тем как непосредственно выполнить сравнение, приводит операнды к одному типу. В случае же, абстрактного реляционного сравнения, операнды сперва преобразуются в примитивы, затем приводятся к одному типу, и только после этого сравниваются.</p>

<p>Строки сравниваются на основе стандартного лексикографического упорядочения, используя значения Unicode.</p>

<p>Особенности сравнений:</p>

<ul>
 <li>Две строки строго равны только в том случае, если они имеют одинаковую длину, и те же символы в одинаковой последовательности и соответствующих позициях.</li>
 <li>Два числа строго равны в том случае, если они численно равны. <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN" title="NaN">NaN</a> не равно ничему, в том числе и NaN. Нули с положительным и отрицательным знаком равны.</li>
 <li>Два логических значения (boolean) равны только в том случае, если они оба <code>истинны (true)</code> или <code>ложны (false</code>).</li>
 <li>Два различных объекта никогда не равны как в строгих, так и в абстрактных сравнениях.</li>
 <li>Сравнение объекта истинно лишь в том случае, если оба операнда ссылаются на один и тот же объект в памяти.</li>
 <li>Виды <code>null</code> и <code>undefined</code> равны себе как в строгом сравнении, так и в абстрактном.</li>
</ul>

<p><strong>При использовании сравнения с преобразованием типов, следует быть крайне осторожным, так как это может привести к непредвиденным проблемам, связанным с особенностями конвертации различных типов (см. параграф "Использование операторов равенства").</strong></p>

<h2 id="Операторы_равенства">Операторы равенства</h2>

<h3 id="Равенство_()"><a name="Equality">Равенство (==)</a></h3>

<p><em>Оператор равенства</em> сначала приводит операнды к одному типу, и затем применяет строгое сравнение. Если оба операнда являются объектами, то JavaScript сравнивает внутренние ссылки, которые равны в том случае, если они ссылаются на один и тот же объект в памяти.</p>

<h4 id="Синтаксис">Синтаксис</h4>

<pre class="syntaxbox">
x == y
</pre>

<h4 id="Примеры">Примеры</h4>

<pre class="brush: js">
 1  ==  1      // истина
"1" ==  1      // истина
 1  == '1'     // истина
 3  ==  5      // ложь
 0  == false   // истина
"foo" == "bar" // ложь
</pre>

<h3 id="Неравенство_(!)"><a name="Inequality">Неравенство (!=)</a></h3>

<p><em>Оператор неравенства</em> возвращает <code>true</code> в том случае, если операнды не равны. <em>Оператор неравенства</em>, аналогично оператору равенства, перед сравнением приводит операнды к одному типу. В случае если оба операнда являются объектами,&nbsp; JavaScript сравнивает внутренние ссылки, которые не равны в том случае, если относятся к разным объектам в памяти.</p>

<h4 id="Синтаксис_2">Синтаксис</h4>

<pre class="syntaxbox">
x != y</pre>

<h4 id="Примеры_2">Примеры</h4>

<pre class="brush: js">
1 !=   2       // истина
1 !=  "1"      // ложь
1 !=  '1'      // ложь
1 !=  true     // ложь
0 !=  false    // ложь
"foo" != "bar" // истина
</pre>

<h3 id="Идентичность_строгое_равенство_()"><a name="Identity">Идентичность / строгое равенство (===)</a></h3>

<p>Оператор возвращает истинну в том случае, если операнды строго равны (см. выше). В отличие от <em>оператора равенства</em>, данный оператор <strong>не приводит операнды к одному типу.</strong></p>

<h4 id="Синтаксис_3">Синтаксис</h4>

<pre class="syntaxbox">
x === y</pre>

<h4 id="Примеры_3">Примеры</h4>

<pre class="brush: js ">
3 === 3   // истина
3 === '3' // ложь
'foo' === 'foo' // истина
</pre>

<h3 id="Неидентичность_строгое_неравенство_(!)"><a name="Nonidentity">Неидентичность / строгое неравенство (!==)</a></h3>

<p><em>Оператор строгого неравенства</em> возвращает истину в том случае, <strong>если операнды не равны, или их типы отличаются друг от друга.</strong></p>

<h4 id="Синтаксис_4">Синтаксис</h4>

<pre class="syntaxbox">
x !== y</pre>

<h4 id="Примеры_4">Примеры</h4>

<pre class="brush: js">
3 !== '3' // истина
4 !== 3   // истина
</pre>

<p>&nbsp;</p>

<h2 id="Относительные_(реляционные)_операторы">Относительные&nbsp; (реляционные) операторы</h2>

<h3 id="Больше_чем_(&gt;)"><a name="Greater_than_operator">Больше чем (&gt;)</a></h3>

<p><em>Оператор более чем</em> возвращает истину в том случае, если значение левого операнда больше чем правого.</p>

<h4 id="Синтаксис_5">Синтаксис</h4>

<pre class="syntaxbox">
x &gt; y</pre>

<h4 id="Примеры_5">Примеры</h4>

<pre class="brush: js">
4 &gt; 3 // истина
1 &gt; 5 // ложь
</pre>

<h3 id="Больше_или_равно_(&gt;)"><a name="Greater_than_or_equal_operator">Больше или равно (&gt;=)</a></h3>

<p><em>Оператор больше или равно, </em>возвращает истину в том случае, если значение операнда слева больше или равно значению операнда справа.</p>

<h4 id="Синтаксис_6">Синтаксис</h4>

<pre class="syntaxbox">
 x &gt;= y</pre>

<h4 id="Примеры_6">Примеры</h4>

<pre class="brush: js">
4 &gt;= 3 // истина
3 &gt;= 3 // истина
</pre>

<h3 id="Меньше_чем_(&lt;)"><a name="Less_than_operator">Меньше чем (&lt;)</a></h3>

<p><em>Оператор меньше чем, </em>возвращает истину в том случае, если значение операнда слева меньше, чем значение операнда справа.</p>

<h4 id="Синтаксис_7">Синтаксис</h4>

<pre class="syntaxbox">
 x &lt; y</pre>

<h4 id="Примеры_7">Примеры</h4>

<pre class="brush: js">
3 &lt; 4 // истина
5 &lt; 2 // ложь
</pre>

<h3 id="Меньше_или_равно_(&lt;)"><a id="Less_than_or_equal_operator" name="Less_than_or_equal_operator">Меньше или равно (&lt;=)</a></h3>

<p><em>Оператор меньше или равно, </em>возвращает истину в том случае, если значение операнда слева меньше, или равно, значению операнда справа.</p>

<h4 id="Синтаксис_8">Синтаксис</h4>

<pre class="syntaxbox">
 x &lt;= y</pre>

<h4 id="Примеры_8">Примеры</h4>

<pre class="brush: js">
3 &lt;= 4 // истина
3 &lt;= 3 // истина
</pre>

<h2 id="Использование_операторов_равенства">Использование операторов равенства</h2>

<p>Стандартные операции равенства с преобразованием типов (<code>==</code> и <code>!=</code>) используют <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3">Абстрактный Алгоритм Эквивалентного Сравнения</a> для сравнения двух операндов. Если операнды имеют различные типы, то JavaScript пытается привести их к одному типу, перед тем как сравнивать их. К примеру, в выражении <code>5 == '5'</code>, строка справа конвертируется в число, и только потом сравнивается.</p>

<p><em>Операторы строгого равентсва</em> (<code>===</code> и <code>!==</code>) используют Строгий Алгоритм Эквивалентного Сравнения, и предназначены для сравнения операндов одного типа. <strong>Если операнды имеют разные типы, то результат операции сравнения всегда будет ложью.</strong> К примеру, выражение <code>5 !== '5'</code> будет истинным.</p>

<p>Используйте <em>операторы строгого равенства</em> в тех случаях, когда необходимо проверять не только значения операндов, но так же и их типы. Во противном случае, используйте операторы стандартного равенства, которые позволяют сравнить два операнда вне зависимости от их типов.</p>

<p>Когда происходит преобразование типов (т.е в случаях использования нестрогого сравнения), JavaScript преобразует типы String, Number, Boolean и Object, следующим образом:</p>

<ul>
 <li>При сравнении числа <code>(Number)</code> и строки <code>(String)</code>, JavaScript пытается преобразовать числовой литерал строки в число. Затем полученное число округляется до ближайшего возможного значения типа <code>Number</code>.</li>
 <li>Если один из операндов является логическим <code>(Boolean)</code>, то он преобразуется в значение типа <code>(Number)</code>. <strong>Если значение логического операнда равняется истине <code>(true)</code>, то значение этого операнда преобразуется в 1. Иначе - в 0 <code>(ложь / false)</code>.</strong></li>
 <li>Если объект сравнивается с числом или строкой, JavaScript пытается получить значение по умолчанию для данного объекта. Полученное значение преобразуется в примитив, посредством методов <strong><code>valueOf()</code></strong> и <strong><code>toString()</code></strong>. Если преобразовать объект не удается, генерируется runtime-ошибка.</li>
 <li>Обратите внимание на то, что объект преобразуется в примитив, если, и только если, второй операнд является примитивом. В ином случае, операнды сравниваются как объекты, соответственно, операция сравнения вернет истину в том случае, если внутренние ссылки обоих объектов ссылаются на один и тот же объект в памяти.</li>
</ul>

<div class="note"><strong>Внимание:</strong> Объекты типа String имеют тип Object, а не String. Такие объекты используются редко, так что следующий код может вас сильно удивить.</div>

<pre class="brush:js">
// Истина, так как оба операнда имеют тип String
'foo' === 'foo'

var a = new String('foo');
var b = new String('foo');

// Ложь, так как операнды являются объектами, внутренние ссылки которых, ссылаются на разные объекты в памяти
a == b 

// Ложь, так как операнды являются объектами, внутренние ссылки которых, ссылаются на разные объекты в памяти
a === b 

// Истина, так как объект a (String) будет преобразован в строку 'foo', перед сопоставлением
a == 'foo' </pre>

<h2 id="Спецификации">Спецификации</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Спецификация</th>
   <th scope="col">Статус</th>
   <th scope="col">Комментарий</th>
  </tr>
  <tr>
   <td>ECMAScript 1st Edition.</td>
   <td>Standard</td>
   <td>Появление в спецификации. Имплементировано в JavaScript 1.0</td>
  </tr>
  <tr>
   <td>ECMAScript 3rd Edition.</td>
   <td>Standard</td>
   <td>Добавлен оператор <code>===</code> и <code>!== </code>. Имплементировано в JavaScript 1.3</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-11.8', 'Relational Operators')}}<br />
    {{SpecName('ES5.1', '#sec-11.9', 'Equality Operators')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td>&nbsp;</td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-relational-operators', 'Relational Operators')}}<br />
    {{SpecName('ES6', '#sec-equality-operators', 'Equality Operators')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td>&nbsp;</td>
  </tr>
 </tbody>
</table>

<h2 id="Браузерная_совместимость">Браузерная совместимость</h2>

<p>{{CompatibilityTable}}</p>

<div id="compat-desktop">
<table class="compat-table">
 <tbody>
  <tr>
   <th>&nbsp;</th>
   <th>Chrome</th>
   <th>Firefox (Gecko)</th>
   <th>Internet Explorer</th>
   <th>Opera</th>
   <th>Safari</th>
  </tr>
  <tr>
   <td>Базовая поддержка</td>
   <td>{{CompatVersionUnknown}}</td>
   <td>{{CompatVersionUnknown}}</td>
   <td>{{CompatVersionUnknown}}</td>
   <td>{{CompatVersionUnknown}}</td>
   <td>
    <p>{{CompatVersionUnknown}}</p>
   </td>
  </tr>
 </tbody>
</table>
</div>

<div id="compat-mobile">
<table class="compat-table" style="height:73px; width:1078px">
 <tbody>
  <tr>
   <th>&nbsp;</th>
   <th>Android</th>
   <th>Chrome for Android</th>
   <th>Firefox Mobile (Gecko)</th>
   <th>IE Mobile</th>
   <th>Opera Mobile</th>
   <th>Safari Mobile</th>
  </tr>
  <tr>
   <td>Базовая поддержка</td>
   <td>{{CompatVersionUnknown}}</td>
   <td>{{CompatVersionUnknown}}</td>
   <td>{{CompatVersionUnknown}}</td>
   <td>{{CompatVersionUnknown}}</td>
   <td>{{CompatVersionUnknown}}</td>
   <td>{{CompatVersionUnknown}}</td>
  </tr>
 </tbody>
</table>
</div>

<h2 id="Смотрите_также"><br />
 Смотрите также</h2>

<ul>
 <li>{{jsxref("Object.is()")}}</li>
 <li><a href="/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness">Эквивалентные сравнения и одинаковость</a></li>
</ul>

